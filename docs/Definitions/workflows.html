

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Workflows &mdash; dichlib 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Definitions and conventions" href="spg_def.html" />
    <link rel="prev" title="Space Group Operation" href="space_group_operation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> dichlib
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dichlib.html">dichlib package</a></li>
</ul>
<p class="caption"><span class="caption-text">Definitions</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="space_group_operation.html">Space Group Operation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Workflows</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#process-functions-a-way-to-generalize-provenance-in-aiida">Process functions: a way to generalize provenance in AiiDA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#function-nesting">Function nesting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#run-a-simple-workflow">Run a simple workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="#run-multiple-calculations">Run multiple calculations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#workchains-or-how-not-to-get-lost-if-your-computer-shuts-down-or-crashes">Workchains, or how not to get lost if your computer shuts down or crashes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="spg_def.html">Definitions and conventions</a></li>
</ul>
<p class="caption"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">dichlib</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">dichlib</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Workflows</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/definitions/workflows.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="workflows">
<h1>Workflows<a class="headerlink" href="#workflows" title="Permalink to this headline">¶</a></h1>
<p>The aim of the last part of this tutorial is to introduce the concept of workflows in AiiDA.</p>
<p>In this section, we will ask you to:</p>
<ol class="arabic simple">
<li><p>Understand how to keep the provenance when running small python scripts to convert one data object into another (postprocessing, preparation of inputs, etc.)</p></li>
<li><p>Understand how to represent simple python functions in the AiiDA database</p></li>
<li><p>Learn how to write a simple workflow in AiiDA (without and with remote calculation submission)</p></li>
<li><p>Learn how to write a workflow with checkpoints: this means that, even if your workflow requires external calculations to start, they and their dependencies are managed through the daemon.
While you are waiting for the calculations to complete, you can stop and even shutdown the computer in which AiiDA is running.
When you restart, the workflow will continue from where it was.</p></li>
<li><p>(optional) Go a bit deeper in the syntax of workflows with checkpoints (<code class="docutils literal notranslate"><span class="pre">WorkChain</span></code>), e.g. implementing a convergence workflow using <code class="docutils literal notranslate"><span class="pre">while</span></code> loops.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is probably the most ‘complex’ part of the tutorial.
We suggest that you try to understand the underlying logic behind the scripts, without focusing too much on the details of the workflows implementation or the syntax.
If you want, you can then focus more on the technicalities in a second reading.</p>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The ultimate aim of this section is to create a workflow to calculate the equation of state of silicon.
This is a very common task for an <em>ab initio</em> researcher.
An equation of state consists in calculating the total energy (E) as a function of the unit cell volume (V).
The minimal energy is reached at the equilibrium volume.
Equivalently, the equilibrium is defined by a vanishing pressure (p=-dE/dV).
In the vicinity of the minimum, the functional form of the equation of state can be approximated by a parabola.
Such an approximation greatly simplifies the calculation of the bulk modulus, that is proportional to the second derivative of the energy (a more advanced treatment requires fitting the curve with, e.g., the Birch–Murnaghan expression).</p>
<p>The process of calculating an equation of state puts together several operations.
First, we need to define and store in the AiiDA database the basic structure of, e.g., bulk Si.
Next, one has to define several structures with different lattice parameters.
Those structures must be connected between them in the database, in order to ensure that their provenance is recorded.
In other words, we want to be sure that in the future we will know that if we find a bunch of rescaled structures in the database, they all descend from the same one.
How to link two nodes in the database in an easy way is the subject of <a class="reference internal" href="#chiba-provenancewf"><span class="std std-ref">Process functions: a way to generalize provenance in AiiDA</span></a>.</p>
<p>In the following sections, the newly created structures will then serve as an input for total energy calculations performed, in this tutorial, with Quantum ESPRESSO.
This task is very similar to what you have done in the previous part of the tutorial.
Finally, you will fit the resulting energies as a function of volume to get the bulk modulus.
As the EOS task is very common, we will show how to automate its computation with workflows, and how to deal with both serial and parallel (i.e., independent) execution of multiple tasks.
Finally, we will show how to introduce more complex logic in your workflows such as loops and conditional statements (<span class="xref std std-ref">see this section</span>), with an example on a convergence loop to find iteratively the minimum of an EOS.</p>
</div>
<div class="section" id="process-functions-a-way-to-generalize-provenance-in-aiida">
<span id="chiba-provenancewf"></span><h2>Process functions: a way to generalize provenance in AiiDA<a class="headerlink" href="#process-functions-a-way-to-generalize-provenance-in-aiida" title="Permalink to this headline">¶</a></h2>
<p>Imagine having a function that takes as input a string of the name of a chemical element and generates the corresponding bulk structure as a <code class="docutils literal notranslate"><span class="pre">StructureData</span></code> object.
The function might look like the following snippet:</p>
<p>For the equation of state you need another function that takes as input a <code class="docutils literal notranslate"><span class="pre">StructureData</span></code> object and a rescaling factor, and returns a <code class="docutils literal notranslate"><span class="pre">StructureData</span></code> object with the rescaled lattice parameter:</p>
<p>In order to generate the rescaled starting structures, say for five different lattice parameters you would combine the two functions.
Open a <code class="docutils literal notranslate"><span class="pre">verdi</span> <span class="pre">shell</span></code>, define the two functions from the previous snippets and enter the following commands:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">initial_structure</span> <span class="o">=</span> <span class="n">create_diamond_fcc</span><span class="p">(</span><span class="s1">&#39;Si&#39;</span><span class="p">)</span>
<span class="n">rescaled_structures</span> <span class="o">=</span> <span class="p">[</span><span class="n">rescale</span><span class="p">(</span><span class="n">initial_structure</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">0.98</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)]</span>
</pre></div>
</div>
<p>and store them in the database:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">initial_structure</span><span class="o">.</span><span class="n">store</span><span class="p">()</span>
<span class="k">for</span> <span class="n">structure</span> <span class="ow">in</span> <span class="n">rescaled_structures</span><span class="p">:</span>
   <span class="n">structure</span><span class="o">.</span><span class="n">store</span><span class="p">()</span>
</pre></div>
</div>
<p>As expected, all the structures that you have created are not linked in any manner as you can verify via the <code class="docutils literal notranslate"><span class="pre">get_incoming()</span></code>/<code class="docutils literal notranslate"><span class="pre">get_outgoing()</span></code> methods of the <code class="docutils literal notranslate"><span class="pre">StuctureData</span></code> class.
Instead, you would like these objects to be connected as sketched in <code class="xref std std-numref docutils literal notranslate"><span class="pre">2019_chiba_fig_provenance_process_functions</span></code>.</p>
<div class="figure align-default" id="id2">
<span id="chiba-fig-provenance-process-functions"></span><img alt="definitions/include/images/process_functions.png" src="definitions/include/images/process_functions.png" />
<p class="caption"><span class="caption-text">Typical graphs created by using calculation and work functions.
(a) The calculation function <code class="docutils literal notranslate"><span class="pre">create_structure</span></code> takes a <code class="docutils literal notranslate"><span class="pre">Str</span></code> object as input and returns a single <code class="docutils literal notranslate"><span class="pre">StructureData</span></code> object which is used as input for the calculation function <code class="docutils literal notranslate"><span class="pre">rescale</span></code> together with a <code class="docutils literal notranslate"><span class="pre">Float</span></code> object.
This latter calculation function returns another <code class="docutils literal notranslate"><span class="pre">StructureData</span></code> object, defining a crystal with a rescaled lattice constant.
(b) Graph generated by a work function that calls two calculation functions.
A wrapper work function <code class="docutils literal notranslate"><span class="pre">create_rescaled</span></code> calls serially the calculation functions <code class="docutils literal notranslate"><span class="pre">create_structure</span></code> and <code class="docutils literal notranslate"><span class="pre">rescale</span></code>.
This relationship is stored via <code class="docutils literal notranslate"><span class="pre">CALL</span></code> links.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>Now that you are familiar with AiiDA, you know that the way to connect two data nodes is through a calculation.
In order to ‘wrap’ python functions and automate the generation of the needed links, in AiiDA we provide you with what we call ‘process functions’.
There are two variants of process functions:</p>
<blockquote>
<div><ul class="simple">
<li><p>calculation functions</p></li>
<li><p>work functions</p></li>
</ul>
</div></blockquote>
<p>These operate mostly the same, but they should be used for different purposes, which will become clear later.
A normal function can be converted to a calculation function by using the <code class="docutils literal notranslate"><span class="pre">&#64;calcfunction</span></code> decorator <a class="footnote-reference brackets" href="#f1" id="id1">1</a> that takes care of storing the execution as a calculation and adding the links between the input and output data nodes.</p>
<p>To turn the original functions <code class="docutils literal notranslate"><span class="pre">create_diamond_fcc</span></code> and <code class="docutils literal notranslate"><span class="pre">rescale</span></code> into calculation functions, simply change the definition as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add this import</span>
<span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="kn">import</span> <span class="n">calcfunction</span>

<span class="c1"># Add decorators</span>
<span class="nd">@calcfunction</span>
<span class="k">def</span> <span class="nf">create_diamond_fcc</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="o">...</span> <span class="p">(</span><span class="n">same</span> <span class="k">as</span> <span class="n">above</span><span class="p">)</span>

<span class="nd">@calcfunction</span>
<span class="k">def</span> <span class="nf">rescale</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="o">...</span> <span class="p">(</span><span class="n">same</span> <span class="k">as</span> <span class="n">above</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the only change is that the function definitions were ‘decorated’ with the <code class="docutils literal notranslate"><span class="pre">&#64;calcfunction</span></code> line.
This is the only thing that is necessary to transform the plain python functions magically into fully-fledged AiiDA process functions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The only additional change necessary, is that process function input and outputs need to be <code class="docutils literal notranslate"><span class="pre">Data</span></code> nodes, so that they can be stored in the database.
AiiDA objects such as <code class="docutils literal notranslate"><span class="pre">StructureData</span></code>, <code class="docutils literal notranslate"><span class="pre">Dict</span></code>, etc. carry around information about their provenance as stored in the database.
This is why we must use the special database-storable types <code class="docutils literal notranslate"><span class="pre">Float</span></code>, <code class="docutils literal notranslate"><span class="pre">Str</span></code>, etc. as shown in the snippet below.</p>
</div>
<p>Try now to run the following script:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="kn">import</span> <span class="n">Float</span><span class="p">,</span> <span class="n">Str</span>
<span class="n">initial_structure</span> <span class="o">=</span> <span class="n">create_diamond_fcc</span><span class="p">(</span><span class="n">Str</span><span class="p">(</span><span class="s1">&#39;Si&#39;</span><span class="p">))</span>
<span class="n">rescaled_structures</span> <span class="o">=</span> <span class="p">[</span><span class="n">rescale</span><span class="p">(</span><span class="n">initial_structure</span><span class="p">,</span> <span class="n">Float</span><span class="p">(</span><span class="n">factor</span><span class="p">))</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">0.98</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)]</span>
</pre></div>
</div>
<p>and check now that the output of <code class="docutils literal notranslate"><span class="pre">initial_structure</span></code> as well as the input of the rescaled structures point to an intermediate node, representing the execution of the calculation function, see <code class="xref std std-numref docutils literal notranslate"><span class="pre">2019_chiba_fig_provenance_process_functions</span></code>.
For instance, you can check that the output links of <code class="docutils literal notranslate"><span class="pre">initial_structure</span></code> are the five <code class="docutils literal notranslate"><span class="pre">rescale</span></code> calculations:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">initial_structure</span><span class="o">.</span><span class="n">get_outgoing</span><span class="p">()</span><span class="o">.</span><span class="n">all_nodes</span><span class="p">()</span>
</pre></div>
</div>
<p>which outputs</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>&lt;CalcFunctionNode: uuid: 9bc5e0f5-fbe4-4fad-a0d1-cf5893dac132 <span class="o">(</span>pk: <span class="m">437</span><span class="o">)</span> <span class="o">(</span>abc.rescale<span class="o">)</span>&gt;,
 &lt;CalcFunctionNode: uuid: 338858ce-779b-455a-8fad-6ac71ba0d1e3 <span class="o">(</span>pk: <span class="m">434</span><span class="o">)</span> <span class="o">(</span>abc.rescale<span class="o">)</span>&gt;,
 &lt;CalcFunctionNode: uuid: 0c601f8c-aa49-4957-bea1-cd796de4a323 <span class="o">(</span>pk: <span class="m">431</span><span class="o">)</span> <span class="o">(</span>abc.rescale<span class="o">)</span>&gt;,
 &lt;CalcFunctionNode: uuid: bbe4fab4-6939-4f05-8bcd-5120e03ddade <span class="o">(</span>pk: <span class="m">428</span><span class="o">)</span> <span class="o">(</span>abc.rescale<span class="o">)</span>&gt;,
 &lt;CalcFunctionNode: uuid: d5e68e04-8ab7-4f3a-90ff-a61f7fd4c247 <span class="o">(</span>pk: <span class="m">425</span><span class="o">)</span> <span class="o">(</span>abc.rescale<span class="o">)</span>&gt;<span class="o">]</span>
</pre></div>
</div>
<p>and the inputs of each <code class="docutils literal notranslate"><span class="pre">CalcFunctionNode</span></code> ‘rescale’ are obtained with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">structure</span> <span class="ow">in</span> <span class="n">initial_structure</span><span class="o">.</span><span class="n">get_outgoing</span><span class="p">()</span><span class="o">.</span><span class="n">all_nodes</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">get_incoming</span><span class="p">()</span><span class="o">.</span><span class="n">all_nodes</span><span class="p">())</span>
</pre></div>
</div>
<p>that will return</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>&lt;StructureData: uuid: 65f50f4c-9925-4362-9c6e-f82eea83f6ce <span class="o">(</span>pk: <span class="m">423</span><span class="o">)</span>&gt;, &lt;Float: uuid: 2adb3204-4686-4f6f-a1f5-dc2df7d4aff7 <span class="o">(</span>pk: <span class="m">436</span><span class="o">)</span> value: <span class="m">1</span>.2&gt;<span class="o">]</span>
<span class="o">[</span>&lt;StructureData: uuid: 65f50f4c-9925-4362-9c6e-f82eea83f6ce <span class="o">(</span>pk: <span class="m">423</span><span class="o">)</span>&gt;, &lt;Float: uuid: 047406f8-c72c-4e7f-8fb2-947b81a60652 <span class="o">(</span>pk: <span class="m">433</span><span class="o">)</span> value: <span class="m">1</span>.1&gt;<span class="o">]</span>
<span class="o">[</span>&lt;StructureData: uuid: 65f50f4c-9925-4362-9c6e-f82eea83f6ce <span class="o">(</span>pk: <span class="m">423</span><span class="o">)</span>&gt;, &lt;Float: uuid: 06c4a6d8-e1a2-4ddc-851d-0fe70860a96b <span class="o">(</span>pk: <span class="m">430</span><span class="o">)</span> value: <span class="m">1</span>.0&gt;<span class="o">]</span>
<span class="o">[</span>&lt;StructureData: uuid: 65f50f4c-9925-4362-9c6e-f82eea83f6ce <span class="o">(</span>pk: <span class="m">423</span><span class="o">)</span>&gt;, &lt;Float: uuid: 1e1a3af3-7c76-41ff-b002-2885121cbd9e <span class="o">(</span>pk: <span class="m">427</span><span class="o">)</span> value: <span class="m">0</span>.99&gt;<span class="o">]</span>
<span class="o">[</span>&lt;StructureData: uuid: 65f50f4c-9925-4362-9c6e-f82eea83f6ce <span class="o">(</span>pk: <span class="m">423</span><span class="o">)</span>&gt;, &lt;Float: uuid: 0f0cef0b-f1fd-4bf4-b264-78a84ebd5db8 <span class="o">(</span>pk: <span class="m">424</span><span class="o">)</span> value: <span class="m">0</span>.98&gt;<span class="o">]</span>
</pre></div>
</div>
<div class="section" id="function-nesting">
<h3>Function nesting<a class="headerlink" href="#function-nesting" title="Permalink to this headline">¶</a></h3>
<p>Calculation functions can be ‘chained’ together by wrapping them together in a work function.
The work function works almost exactly the same as a calculation function, except that it cannot ‘create’ data, but rather is used to ‘call’ calculation functions that do the calculations for it.
The calculation functions that it calls will be automatically linked in the provenance graph through ‘call’ links.
As an example, let us combine the two previously defined calculation functions by means of a wrapper work function called ‘create_rescaled’ that takes as input the element and the rescale factor.</p>
<p>Type in your shell (or modify the functions defined in <code class="docutils literal notranslate"><span class="pre">create_rescale.py</span></code> and then run):</p>
<p>and create an already rescaled structure by typing</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rescaled</span> <span class="o">=</span> <span class="n">create_rescaled</span><span class="p">(</span><span class="n">element</span><span class="o">=</span><span class="n">Str</span><span class="p">(</span><span class="s1">&#39;Si&#39;</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="n">Float</span><span class="p">(</span><span class="mf">0.98</span><span class="p">))</span>
</pre></div>
</div>
<p>Now inspect the input links of <code class="docutils literal notranslate"><span class="pre">rescaled</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="n">rescaled</span><span class="o">.</span><span class="n">get_incoming</span><span class="p">()</span><span class="o">.</span><span class="n">all_nodes</span><span class="p">()</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span>
<span class="p">[</span><span class="o">&lt;</span><span class="n">WorkFunctionNode</span><span class="p">:</span> <span class="n">uuid</span><span class="p">:</span> <span class="n">d6afac0e</span><span class="o">-</span><span class="n">d1b3</span><span class="o">-</span><span class="mi">4</span><span class="n">d66</span><span class="o">-</span><span class="mi">9689</span><span class="o">-</span><span class="mi">8</span><span class="n">b3347e6e315</span> <span class="p">(</span><span class="n">pk</span><span class="p">:</span> <span class="mi">441</span><span class="p">)</span> <span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">create_rescaled</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="o">&lt;</span><span class="n">CalcFunctionNode</span><span class="p">:</span> <span class="n">uuid</span><span class="p">:</span> <span class="mi">83</span><span class="n">b94be8</span><span class="o">-</span><span class="n">ded5</span><span class="o">-</span><span class="mi">4</span><span class="n">dcf</span><span class="o">-</span><span class="n">a929</span><span class="o">-</span><span class="mi">3</span><span class="n">d57301d4dde</span> <span class="p">(</span><span class="n">pk</span><span class="p">:</span> <span class="mi">444</span><span class="p">)</span> <span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">rescale</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<p>The object <code class="docutils literal notranslate"><span class="pre">rescaled</span></code> has two incoming links, corresponding to <em>two</em> different calculations as input.
These correspond to the calculations ‘create_rescaled’ and ‘rescale’ as shown in <code class="xref std std-numref docutils literal notranslate"><span class="pre">2019_chiba_fig_provenance_process_functions</span></code>.
To see the ‘call’ link, inspect now the outputs of the <code class="docutils literal notranslate"><span class="pre">WorkFunctionNode</span></code> which corresponds to the <code class="docutils literal notranslate"><span class="pre">create_rescaled</span></code> work function.
Write down its <code class="docutils literal notranslate"><span class="pre">&lt;pk&gt;</span></code> (in general, it will be different from 441), then in the shell load the corresponding node and inspect the outputs:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">12</span><span class="p">]:</span> <span class="n">node</span> <span class="o">=</span> <span class="n">load_node</span><span class="p">(</span><span class="o">&lt;</span><span class="n">pk</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">13</span><span class="p">]:</span> <span class="n">node</span><span class="o">.</span><span class="n">get_outgoing</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>You should be able to identify the two children calculations as well as the final structure (you will see the process nodes linked via CALL links: these are process-to-process links representing the fact that <code class="docutils literal notranslate"><span class="pre">create_rescaled</span></code> called two calculation functions).
The graphical representation of what you have in the database should match <code class="xref std std-numref docutils literal notranslate"><span class="pre">2019_chiba_fig_provenance_process_functions</span></code>.</p>
</div>
</div>
<div class="section" id="run-a-simple-workflow">
<span id="chiba-sync"></span><h2>Run a simple workflow<a class="headerlink" href="#run-a-simple-workflow" title="Permalink to this headline">¶</a></h2>
<p>Let us now use the work and calculation functions that we have just created to build a simple workflow to calculate the equation of state of silicon.
We will consider five different values of the lattice parameter obtained rescaling the experimental minimum, <code class="docutils literal notranslate"><span class="pre">a=5.431</span></code>, by a factor in <code class="docutils literal notranslate"><span class="pre">[0.96,</span> <span class="pre">0.98,</span> <span class="pre">1.0,</span> <span class="pre">1.02,</span> <span class="pre">1.04]</span></code>.
We will write a simple script that runs a series of five calculations and at the end returns the volume and the total energy corresponding to each value of the lattice parameter.
For your convenience, besides the functions that you have written so far in the file <code class="docutils literal notranslate"><span class="pre">create_rescale.py</span></code>, we provide you with some other utilities to get the correct pseudopotential and to generate a pw input file, in <code class="xref download docutils literal notranslate"><span class="pre">common_wf.py</span></code>.</p>
<p>We have already created the following script, which you can <code class="xref download docutils literal notranslate"><span class="pre">download</span></code>, but please go through the lines carefully and make sure you understand them.
We suggest that you first have a careful look at it before running it:</p>
<p>If you look into the previous piece of code, you will notice that the way we submit a QE calculation is slightly different from what you have seen in the first part of the tutorial.
The following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">calculations</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="n">PwCalculation</span><span class="p">,</span> <span class="o">**</span><span class="n">inputs</span><span class="p">)</span>
</pre></div>
</div>
<p>runs in the current python session (without the daemon), waits for its completion and returns the output in the user-defined variable <code class="docutils literal notranslate"><span class="pre">result</span></code>.
The latter is a dictionary whose values are the output nodes generated by the work function, with the link labels as keys.
For example once the function is finished, in order to access the total energy, we need to access the <code class="docutils literal notranslate"><span class="pre">Dict</span></code> node which is linked via the ‘output_parameters’ link (see again Fig. 1 of Day 1 Tutorial, to see inputs and outputs of a Quantum ESPRESSO calculation).
Once the right node is retrieved as <code class="docutils literal notranslate"><span class="pre">result['output_parameters']</span></code>, we need to get the <code class="docutils literal notranslate"><span class="pre">energy</span></code> attribute.
The global operation is achieved by the command</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;output_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">energy</span>
</pre></div>
</div>
<p>To collect these results from the various calculations into a single data node, we need one final calculation function to do so.
Since the <code class="docutils literal notranslate"><span class="pre">run_eos_wf</span></code> is a ‘workflow’-like processes, which cannot create data, this operation <strong>cannot</strong> simply be done in the work function body itself.
To keep the provenance <strong>we have to</strong> do this through a calculation function.
This is done by the <code class="docutils literal notranslate"><span class="pre">create_eos_dictionary</span></code> calculation function, that receives as inputs, the output parameters nodes from the completed calculations:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@calcfunction</span>
<span class="k">def</span> <span class="nf">create_eos_dictionary</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a single `Dict` node from the `Dict` output parameters of completed `PwCalculations`.</span>

<span class="sd">    The dictionary will contain a list of tuples, where each tuple contains the volume, total energy and its units</span>
<span class="sd">    of the results of a calculation.</span>

<span class="sd">    :return: `Dict` node with the equation of state results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eos</span> <span class="o">=</span> <span class="p">[(</span><span class="n">result</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">energy_units</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="k">return</span> <span class="n">Dict</span><span class="p">(</span><span class="nb">dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;eos&#39;</span><span class="p">:</span> <span class="n">eos</span><span class="p">})</span>
</pre></div>
</div>
<p>It constructs a new <code class="docutils literal notranslate"><span class="pre">Dict</span></code> node that contains a single value <code class="docutils literal notranslate"><span class="pre">eos</span></code> which is a list of tuples with the relevant data for each calculation.
If you were to inspect the returned data node, with for example <code class="docutils literal notranslate"><span class="pre">verdi</span> <span class="pre">data</span> <span class="pre">dict</span> <span class="pre">show</span></code> you would see something like:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">{</span>
    <span class="s2">&quot;eos&quot;</span>: <span class="o">[</span>
        <span class="o">[</span>
            <span class="m">40</span>.04786949775,
            -308.193208771881,
            <span class="s2">&quot;eV&quot;</span>
        <span class="o">]</span>,
        <span class="o">[</span>
            <span class="m">37</span>.6927343883263,
            -307.990673492459,
            <span class="s2">&quot;eV&quot;</span>
        <span class="o">]</span>,
        <span class="o">[</span>
            <span class="m">35</span>.4317918679613,
            -307.666113525946,
            <span class="s2">&quot;eV&quot;</span>
        <span class="o">]</span>,
        <span class="o">[</span>
            <span class="m">45</span>.048406674717,
            -308.308206255253,
            <span class="s2">&quot;eV&quot;</span>
        <span class="o">]</span>,
        <span class="o">[</span>
            <span class="m">42</span>.4991194939683,
            -308.293522312459,
            <span class="s2">&quot;eV&quot;</span>
        <span class="o">]</span>
    <span class="o">]</span>
<span class="o">}</span>
</pre></div>
</div>
<p>As you see, the function <code class="docutils literal notranslate"><span class="pre">run_eos_wf</span></code> has been decorated as a work function to keep track of the provenance.
To run the workflow it suffices to call the function <code class="docutils literal notranslate"><span class="pre">run_eos_wf</span></code> in a python script providing the required input parameters.
For simplicity, we have included few lines at the end of the script that invoke the function with a static choice of parameters:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_eos</span><span class="p">(</span><span class="n">code</span><span class="o">=</span><span class="n">load_code</span><span class="p">(</span><span class="s1">&#39;qe-6.4.1-pw@localhost&#39;</span><span class="p">),</span> <span class="n">pseudo_family</span><span class="o">=</span><span class="s1">&#39;SSSP&#39;</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="s1">&#39;Si&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_eos_wf</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">Str</span><span class="p">(</span><span class="n">pseudo_family</span><span class="p">),</span> <span class="n">Str</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">run_eos</span><span class="p">()</span>
</pre></div>
</div>
<p>To get a reference to the node that represents the function execution, we can ask the <code class="docutils literal notranslate"><span class="pre">run</span></code> function to return the node, in addition to the results.
Instead of calling the work function to run it, we can use the method <code class="docutils literal notranslate"><span class="pre">run_get_node</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">results</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">run_eos_wf</span><span class="o">.</span><span class="n">run_get_node</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">Str</span><span class="p">(</span><span class="n">pseudo_family</span><span class="p">),</span> <span class="n">Str</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;run_eos_wf&lt;</span><span class="si">{}</span><span class="s1">&gt; completed&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pk</span><span class="p">))</span>
</pre></div>
</div>
<p>Run the workflow:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>verdi run simple_sync_workflow.py
</pre></div>
</div>
<p>The command above locks the shell until the full workflow has completed (we will see in a moment how to avoid this).
While the function is running, you can use (in a different shell) the command <code class="docutils literal notranslate"><span class="pre">verdi</span> <span class="pre">process</span> <span class="pre">list</span></code> to show ongoing and finished processes.
You can ‘grep’ for the <code class="docutils literal notranslate"><span class="pre">&lt;pk&gt;</span></code> you are interested in.
Additionally, you can use the command <code class="docutils literal notranslate"><span class="pre">verdi</span> <span class="pre">process</span> <span class="pre">status</span> <span class="pre">&lt;pk&gt;</span></code> to show the tree of the calculatino functions called by the root work function with a given <code class="docutils literal notranslate"><span class="pre">&lt;pk&gt;</span></code>.</p>
<p>Wait for the work function to finish, then call the function <code class="docutils literal notranslate"><span class="pre">plot_eos(&lt;pk&gt;)</span></code> that we provided in the file <code class="docutils literal notranslate"><span class="pre">common_wf.py</span></code> to plot the equation of state and fit it with a Birch–Murnaghan equation.</p>
</div>
<div class="section" id="run-multiple-calculations">
<span id="chiba-wf-multiple-calcs"></span><h2>Run multiple calculations<a class="headerlink" href="#run-multiple-calculations" title="Permalink to this headline">¶</a></h2>
<p>You should have noticed that the calculations for different lattice parameters are executed serially, although they might perfectly be executed in parallel because their inputs and outputs are not connected in any way.
In the language of workflows, these calculations are executed in a synchronous (or blocking) way, whereas we would like to have them running <em>asynchronously</em> (i.e., in a non-blocking way, to run them in parallel).
One way to achieve this, is to submit the calculation to the daemon using the <code class="docutils literal notranslate"><span class="pre">submit</span></code> function.
Make a copy of the script <code class="docutils literal notranslate"><span class="pre">simple_sync_workflow.py</span></code> that we worked on in the previous section and name it <code class="docutils literal notranslate"><span class="pre">simple_submit_workflow.py</span></code>.
To make the new script work asynchronously, simply change the following subset of lines:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="kn">import</span> <span class="n">run</span>

<span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">scale_factors</span><span class="p">):</span>

    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

    <span class="n">calculations</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="n">PwCalculation</span><span class="p">,</span> <span class="o">**</span><span class="n">inputs</span><span class="p">)</span>

<span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;output_parameters&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">calculations</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="n">eos</span> <span class="o">=</span> <span class="n">create_eos_dictionary</span><span class="p">(</span><span class="o">**</span><span class="n">inputs</span><span class="p">)</span>

<span class="p">[</span><span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>replacing them with</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="kn">import</span> <span class="n">submit</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>

<span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">scale_factors</span><span class="p">):</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

    <span class="c1"># Replace `run` with `submit`</span>
    <span class="n">calculations</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">submit</span><span class="p">(</span><span class="n">PwCalculation</span><span class="p">,</span> <span class="o">**</span><span class="n">inputs</span><span class="p">)</span>

<span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="c1"># Wait for the calculations to finish</span>
<span class="k">for</span> <span class="n">calculation</span> <span class="ow">in</span> <span class="n">calculations</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">calculation</span><span class="o">.</span><span class="n">is_finished</span><span class="p">:</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">get_outgoing</span><span class="p">()</span><span class="o">.</span><span class="n">get_node_by_label</span><span class="p">(</span><span class="s1">&#39;output_parameters&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">calculations</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="n">eos</span> <span class="o">=</span> <span class="n">create_eos_dictionary</span><span class="p">(</span><span class="o">**</span><span class="n">inputs</span><span class="p">)</span>
</pre></div>
</div>
<p>The main differences are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">run</span></code> is replaced by <code class="docutils literal notranslate"><span class="pre">submit</span></code></p></li>
<li><p>The return value of <code class="docutils literal notranslate"><span class="pre">submit</span></code> is not a dictionary describing the outputs of the calculation, but it is the node that represents the execution of that calculation.</p></li>
<li><p>Each calculation starts in the background and calculation nodes are added to the <code class="docutils literal notranslate"><span class="pre">calculations</span></code> dictionary.</p></li>
<li><p>At the end of the loop, when all calculations have been launched with <code class="docutils literal notranslate"><span class="pre">submit</span></code>, another loop is used to wait for all calculations to finish before gathering the results as the final step.</p></li>
</ul>
<p>In the next section we will show you another way to achieve this, which has the added bonus that it introduces checkpoints in the work function, from which the process can be resumed should it be interrupted.
After applying the modifications, run the script.
You will see that all calculations start at the same time, without waiting for the previous ones to finish.</p>
<p>If in the meantime you run <code class="docutils literal notranslate"><span class="pre">verdi</span> <span class="pre">process</span> <span class="pre">status</span> <span class="pre">&lt;pk&gt;</span></code>, all five calculations are already shown as output.
Also, if you run <code class="docutils literal notranslate"><span class="pre">verdi</span> <span class="pre">process</span> <span class="pre">list</span></code>, you will see how the calculations are submitted to the scheduler.</p>
</div>
<div class="section" id="workchains-or-how-not-to-get-lost-if-your-computer-shuts-down-or-crashes">
<span id="chiba-workchainsimple"></span><h2>Workchains, or how not to get lost if your computer shuts down or crashes<a class="headerlink" href="#workchains-or-how-not-to-get-lost-if-your-computer-shuts-down-or-crashes" title="Permalink to this headline">¶</a></h2>
<p>The simple workflows that we have used so far have been launched by a python script that needs to be running for the whole time of the execution, namely the time in which the calculations are submitted, and the actual time needed by Quantum ESPRESSO to perform the calculation and the time taken to retrieve the results.
If you had killed the main python process during this time, the workflow would not have terminated correctly.
Perhaps you killed the calculation and you experienced the unpleasant consequences: intermediate calculation results are potentially lost and it is extremely difficult to restart a workflow from the exact place where it stopped.</p>
<p>In order to overcome this limitation, in AiiDA we have implemented a way to insert checkpoints, where the main code defining a workflow can be stopped (you can even shut down the machine on which AiiDA is running!).
We call these work functions with checkpoints ‘work chains’ because, as you will see, they basically amount to splitting a work function in a chain of steps.
Each step is then ran by the daemon, in a way similar to the remote calculations.</p>
<p>Here below you can find the basic rules that allow you to convert your workfunction-based script to a workchain-based one and a snippet example focusing on the code used to perform the calculation of an equation of state.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>WorkChains need to be defined in a <strong>separate file</strong> from the script used to run them.
E.g. save your WorkChain in <code class="docutils literal notranslate"><span class="pre">workchains.py</span></code> and use <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">workchains</span> <span class="pre">import</span> <span class="pre">MyWorkChain</span></code> to import it in your script.</p>
<p>Furthermore, the directory containing the WorkChain definition needs to be in the <code class="docutils literal notranslate"><span class="pre">PYTHONPATH</span></code> in order for the AiiDA daemon to find it.
If your <code class="docutils literal notranslate"><span class="pre">workchains.py</span></code> sits in <code class="docutils literal notranslate"><span class="pre">/home/max/workchains</span></code>, add a line <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">PYTHONPATH=$PYTHONPATH:/home/max/workchains</span></code> to the <code class="docutils literal notranslate"><span class="pre">/home/max/.virtualenvs/aiida/bin/activate</span></code> script, followed by <code class="docutils literal notranslate"><span class="pre">verdi</span> <span class="pre">daemon</span> <span class="pre">restart</span></code>.</p>
</div>
<ul>
<li><p>Instead of using decorated functions you need to define a class, inheriting from a prototype class called <code class="docutils literal notranslate"><span class="pre">WorkChain</span></code> that is provided by AiiDA in the <code class="docutils literal notranslate"><span class="pre">aiida.engine</span></code> module.</p></li>
<li><p>Within your class you need to implement a <code class="docutils literal notranslate"><span class="pre">define</span></code> classmethod that always takes <code class="docutils literal notranslate"><span class="pre">cls</span></code> and <code class="docutils literal notranslate"><span class="pre">spec</span></code> as inputs.
Here you specify the main information on the workchain, in particular:</p>
<ul class="simple">
<li><p>The <em>inputs</em> that the workchain expects.
This is obtained by means of the <code class="docutils literal notranslate"><span class="pre">spec.input()</span></code> method, which provides as the key feature the automatic validation of the input types via the <code class="docutils literal notranslate"><span class="pre">valid_type</span></code> argument.
The same holds true for outputs, as you can use the <code class="docutils literal notranslate"><span class="pre">spec.output()</span></code> method to state what output types are expected to be returned by the workchain.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">outline</span></code> consisting in a list of ‘steps’ that you want to run, put in the right sequence.
This is obtained by means of the method <code class="docutils literal notranslate"><span class="pre">spec.outline()</span></code> which takes as input the steps.
<em>Note</em>: in this example we just split the main execution in two sequential steps, that is, first <code class="docutils literal notranslate"><span class="pre">run_eos</span></code> then <code class="docutils literal notranslate"><span class="pre">results</span></code>.
However, more complex logic is allowed, as will be explained in <span class="xref std std-ref">another section</span>.</p></li>
</ul>
</li>
<li><p>You need to split your main code into methods, with the names you specified before into the outline (<code class="docutils literal notranslate"><span class="pre">run_eos</span></code> and <code class="docutils literal notranslate"><span class="pre">results</span></code> in this example).
Where exactly should you split the code?
Well, the splitting points should be put where you would normally block the execution of the script for collecting results in a standard work function, namely whenever you call the method <code class="docutils literal notranslate"><span class="pre">.result()</span></code>.
Each method should accept only one parameter, <code class="docutils literal notranslate"><span class="pre">self</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">step_name(self)</span></code>.</p></li>
<li><p>You will notice that the methods reference the attribute <code class="docutils literal notranslate"><span class="pre">ctx</span></code> through <code class="docutils literal notranslate"><span class="pre">self.ctx</span></code>, which is called the <em>context</em> and is inherited from the base class <code class="docutils literal notranslate"><span class="pre">WorkChain</span></code>.
A python function or process function normally just stores variables in the local scope of the function.
For instance, in the example of <a class="reference internal" href="#chiba-sync"><span class="std std-ref">this subsection</span></a>, you stored the completed calculations in the <code class="docutils literal notranslate"><span class="pre">calculations</span></code> dictionary, that was a local variable.</p>
<p>In work chains, instead, to preserve variables between different steps, you need to store them in a special dictionary called <em>context</em>.
As explained above, the context variable <code class="docutils literal notranslate"><span class="pre">ctx</span></code> is inherited from the base class <code class="docutils literal notranslate"><span class="pre">WorkChain</span></code>, and at each step method you just need to update its content.
AiiDA will take care of saving the context somewhere between workflow steps (on disk, in the database, depending on how AiiDA was configured).
For your convenience, you can also access the value of a context variable as <code class="docutils literal notranslate"><span class="pre">self.ctx.varname</span></code> instead of <code class="docutils literal notranslate"><span class="pre">self.ctx['varname']</span></code>.</p>
</li>
<li><p>Any submission within the workflow should not call the normal <code class="docutils literal notranslate"><span class="pre">run</span></code> or <code class="docutils literal notranslate"><span class="pre">submit</span></code> functions, but <code class="docutils literal notranslate"><span class="pre">self.submit</span></code> to which you have to pass the process class, and a dictionary of inputs.</p></li>
<li><p>The submission in <code class="docutils literal notranslate"><span class="pre">run_eos</span></code> returns a future and not the actual calculation, because at that point in time we have only just launched the calculation to the daemon and it is not yet completed.
Therefore it literally is a ‘future’ result.
Yet we still need to add these futures to the context, so that in the next step of the workchain, when the calculations are in fact completed, we can access them and continue the work.
To do this, we can use the <code class="docutils literal notranslate"><span class="pre">ToContext</span></code> class.
This class takes a dictionary, where the values are the futures and the keys will be the names under which the corresponding calculations will be made available in the context when they are done.
See how the <code class="docutils literal notranslate"><span class="pre">ToContext</span></code> object is created and returned in <code class="docutils literal notranslate"><span class="pre">run_eos</span></code>.
By doing this, the workchain will implicitly wait for the results of all the futures you have specified, and then call the next step <em>only when all futures have completed</em>.</p></li>
<li><p><em>Return values</em>: While in normal process functions you attach output nodes to the node by invoking the <em>return</em> statement, in a workchain you need to call <code class="docutils literal notranslate"><span class="pre">self.out(link_name,</span> <span class="pre">node)</span></code> for each node you want to return.
Of course, if you have already prepared a dictionary of outputs, you can just use the following syntax:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">out_many</span><span class="p">(</span><span class="n">retdict</span><span class="p">)</span>  <span class="c1"># Keys are link names, value the nodes</span>
</pre></div>
</div>
<p>The advantage of this different syntax is that you can start emitting output nodes already in the middle of the execution, and not necessarily at the very end as it happens for normal functions (<em>return</em> is always the last instruction executed in a function or method).
Also, note that once you have called <code class="docutils literal notranslate"><span class="pre">self.out(link_name,</span> <span class="pre">node)</span></code> on a given <code class="docutils literal notranslate"><span class="pre">link_name</span></code>, you can no longer call <code class="docutils literal notranslate"><span class="pre">self.out()</span></code> on the same <code class="docutils literal notranslate"><span class="pre">link_name</span></code>: this will raise an exception.</p>
</li>
</ul>
<p>Finally, the workflow has to be run.
For this you have to use the function <code class="docutils literal notranslate"><span class="pre">run</span></code> passing as arguments the <code class="docutils literal notranslate"><span class="pre">EquationOfState</span></code> class and the inputs as key-value arguments.
For example, you can execute:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="kn">import</span> <span class="n">run</span>
<span class="n">run</span><span class="p">(</span><span class="n">EquationOfState</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="n">Str</span><span class="p">(</span><span class="s1">&#39;Si&#39;</span><span class="p">),</span> <span class="n">code</span><span class="o">=</span><span class="n">load_code</span><span class="p">(</span><span class="s1">&#39;qe-6.4.1-pw@localhost&#39;</span><span class="p">),</span> <span class="n">pseudo_family</span><span class="o">=</span><span class="n">Str</span><span class="p">(</span><span class="s1">&#39;SSSP&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>While the workflow is running, you can check (in a different terminal) what is happening to the calculations using <code class="docutils literal notranslate"><span class="pre">verdi</span> <span class="pre">process</span> <span class="pre">list</span></code>.
You will see that after a few seconds the calculations are all submitted to the scheduler and can potentially run at the same time.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The calculations launched by the work chain will now be submitted to the daemon, instead of run in the same interpreter
However, by using <code class="docutils literal notranslate"><span class="pre">run</span></code> on the work chain itself, it will still not be able to restart.
To make the work chain save its checkpoints, you should use the <code class="docutils literal notranslate"><span class="pre">submit</span></code> launcher instead.</p>
</div>
<p>As an additional exercise (optional), instead of running the main workflow <code class="docutils literal notranslate"><span class="pre">EquationOfState</span></code>, try to submit it.
Note that the file where the work chains is defined will need to be globally importable (so the daemon knows how to load it) and you need to launch it (with <code class="docutils literal notranslate"><span class="pre">submit</span></code>) from a different python file.
The easiest way to achieve this is typically to embed the workflow inside a python package.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As good practice, you should try to keep the steps as short as possible in term of execution time.
The reason is that the daemon can be stopped and restarted only between execution steps and not if a step is in the middle of a long execution.</p>
</div>
<p>Finally, as an optional exercise if you have time, you can jump to <span class="xref std std-ref">this appendix</span>, which shows how to introduce more complex logic into your work chains (if conditionals, while loops etc.).
The exercise will show how to realize a convergence loop to obtain the minimum-volume structure in a EOS using the Newton’s algorithm.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You might see warnings that say <code class="docutils literal notranslate"><span class="pre">Exception</span> <span class="pre">trying</span> <span class="pre">to</span> <span class="pre">save</span> <span class="pre">checkpoint,</span> <span class="pre">this</span> <span class="pre">means</span> <span class="pre">you</span> <span class="pre">will</span> <span class="pre">not</span> <span class="pre">be</span> <span class="pre">able</span> <span class="pre">to</span> <span class="pre">restart</span> <span class="pre">in</span> <span class="pre">case</span> <span class="pre">of</span> <span class="pre">a</span> <span class="pre">crash</span> <span class="pre">until</span> <span class="pre">the</span> <span class="pre">next</span> <span class="pre">successful</span> <span class="pre">checkpoint</span></code>.
These are generated by the <code class="docutils literal notranslate"><span class="pre">PwCalculation</span></code> which is unable to save a checkpoint because it is not in a so called ‘importable path’.
Simply put, this means that if AiiDA were to try and reload the class it wouldn’t know which file to find it in.
To get around this you could simply put the workchain in a different file that is in the ‘PYTHONPATH’ and then launch it by importing it in your launch file.
In this way AiiDA knows where to find it next time it loads the checkpoint.</p>
</div>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>In simple words, a decorator is a function that modifies the behavior of another function. In python, a function can be decorated by adding a line of the form <code class="docutils literal notranslate"><span class="pre">&#64;decorating_function_name</span></code> on the line just before the <code class="docutils literal notranslate"><span class="pre">def</span></code> line of the decorated function. If you want to know more, there are many online resources explaining python decorators.</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="spg_def.html" class="btn btn-neutral float-right" title="Definitions and conventions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="space_group_operation.html" class="btn btn-neutral float-left" title="Space Group Operation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Keiyu Mizokami

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>