

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Definitions and conventions &mdash; dichlib 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="dichlib" href="../modules.html" />
    <link rel="prev" title="Space Group Operation" href="space_group_operation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> dichlib
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dichlib.html">dichlib package</a></li>
</ul>
<p class="caption"><span class="caption-text">Definitions</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="space_group_operation.html">Space Group Operation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Definitions and conventions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
<li class="toctree-l2"><a class="reference internal" href="#space-group-operation-and-change-of-basis">Space group operation and change of basis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basis-vectors-mathbf-a-mathbf-b-mathbf-c-or-mathbf-a-1-mathbf-a-2-mathbf-a-3">Basis vectors <span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}, \mathbf{c})\)</span> or <span class="math notranslate nohighlight">\((\mathbf{a}_1, \mathbf{a}_2, \mathbf{a}_3)\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomic-point-coordinates-boldsymbol-x">Atomic point coordinates <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="#symmetry-operation-boldsymbol-w-boldsymbol-w">Symmetry operation <span class="math notranslate nohighlight">\((\boldsymbol{W}, \boldsymbol{w})\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="#transformation-matrix-boldsymbol-p-and-origin-shift-boldsymbol-p">Transformation matrix <span class="math notranslate nohighlight">\(\boldsymbol{P}\)</span> and origin shift <span class="math notranslate nohighlight">\(\boldsymbol{p}\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="#difference-between-rotation-and-transformation-matrices">Difference between rotation and transformation matrices</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#spglib-conventions-of-standardized-unit-cell">Spglib conventions of standardized unit cell</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#choice-of-basis-vectors">Choice of basis vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transformation-to-the-primitive-cell">Transformation to the primitive cell</a></li>
<li class="toctree-l3"><a class="reference internal" href="#def-idealize-cell">Idealization of unit cell structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#triclinic-lattice">Triclinic lattice</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monoclinic-lattice">Monoclinic lattice</a></li>
<li class="toctree-l4"><a class="reference internal" href="#orthorhombic-lattice">Orthorhombic lattice</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tetragonal-lattice">Tetragonal lattice</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhombohedral-lattice">Rhombohedral lattice</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hexagonal-lattice">Hexagonal lattice</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cubic-lattice">Cubic lattice</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rotation-introduced-by-idealization">Rotation introduced by idealization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#crystallographic-choice-and-rigid-rotation">Crystallographic choice and rigid rotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transformation-to-a-primitive-cell">Transformation to a primitive cell</a></li>
<li class="toctree-l3"><a class="reference internal" href="#computing-rigid-rotation-introduced-by-idealization">Computing rigid rotation introduced by idealization</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">dichlib</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">dichlib</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Definitions and conventions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/definitions/spg_def.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="definitions-and-conventions">
<span id="id1"></span><h1>Definitions and conventions<a class="headerlink" href="#definitions-and-conventions" title="Permalink to this headline">Â¶</a></h1>
<p>Information in this page is valid for spglib 1.8.1 or later. The
definitions of transformation matrix and origin shift were different
in the previous versions.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#references" id="id2">References</a></p></li>
<li><p><a class="reference internal" href="#space-group-operation-and-change-of-basis" id="id3">Space group operation and change of basis</a></p>
<ul>
<li><p><a class="reference internal" href="#basis-vectors-mathbf-a-mathbf-b-mathbf-c-or-mathbf-a-1-mathbf-a-2-mathbf-a-3" id="id4">Basis vectors <span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}, \mathbf{c})\)</span> or <span class="math notranslate nohighlight">\((\mathbf{a}_1, \mathbf{a}_2, \mathbf{a}_3)\)</span></a></p></li>
<li><p><a class="reference internal" href="#atomic-point-coordinates-boldsymbol-x" id="id5">Atomic point coordinates <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span></a></p></li>
<li><p><a class="reference internal" href="#symmetry-operation-boldsymbol-w-boldsymbol-w" id="id6">Symmetry operation <span class="math notranslate nohighlight">\((\boldsymbol{W}, \boldsymbol{w})\)</span></a></p></li>
<li><p><a class="reference internal" href="#transformation-matrix-boldsymbol-p-and-origin-shift-boldsymbol-p" id="id7">Transformation matrix <span class="math notranslate nohighlight">\(\boldsymbol{P}\)</span> and origin shift <span class="math notranslate nohighlight">\(\boldsymbol{p}\)</span></a></p></li>
<li><p><a class="reference internal" href="#difference-between-rotation-and-transformation-matrices" id="id8">Difference between rotation and transformation matrices</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#spglib-conventions-of-standardized-unit-cell" id="id9">Spglib conventions of standardized unit cell</a></p>
<ul>
<li><p><a class="reference internal" href="#choice-of-basis-vectors" id="id10">Choice of basis vectors</a></p></li>
<li><p><a class="reference internal" href="#transformation-to-the-primitive-cell" id="id11">Transformation to the primitive cell</a></p></li>
<li><p><a class="reference internal" href="#def-idealize-cell" id="id12">Idealization of unit cell structure</a></p></li>
<li><p><a class="reference internal" href="#rotation-introduced-by-idealization" id="id13">Rotation introduced by idealization</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#examples" id="id14">Examples</a></p>
<ul>
<li><p><a class="reference internal" href="#crystallographic-choice-and-rigid-rotation" id="id15">Crystallographic choice and rigid rotation</a></p></li>
<li><p><a class="reference internal" href="#transformation-to-a-primitive-cell" id="id16">Transformation to a primitive cell</a></p></li>
<li><p><a class="reference internal" href="#computing-rigid-rotation-introduced-by-idealization" id="id17">Computing rigid rotation introduced by idealization</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="references">
<h2><a class="toc-backref" href="#id2">References</a><a class="headerlink" href="#references" title="Permalink to this headline">Â¶</a></h2>
<p>Some references about crystallographic definitions and conventions are
shown below. Though spglib may not follow them fully, it doesnât mean
spglib doesnât respect them, rather it is due to spglib-authorâs lack of
understanding the crystallography ashamedly.</p>
<ul class="simple">
<li><p><a class="reference external" href="http://it.iucr.org/">International Tables for Crystallography</a>.</p></li>
<li><p><a class="reference external" href="http://www.cryst.ehu.es/">Bilbao Crystallographic Server</a>. The
references of many useful papers are found at
<a class="reference external" href="http://www.cryst.ehu.es/wiki/index.php/Articles">http://www.cryst.ehu.es/wiki/index.php/Articles</a>.</p></li>
<li><p>Ulrich MÃ¼ller, âSymmetry Relationships between Crystal Structuresâ</p></li>
<li><p>E. ParthÃ©, K. Cenzual, and R. E. Gladyshevskii, âStandardization of
crystal structure data as an aid to the classification of crystal
structure typesâ, Journal of Alloys and Compounds, <strong>197</strong>, 291-301
(1993). [<a class="reference external" href="https://dx.doi.org/10.1016/0925-8388(93)90049-S">doi2</a>]</p></li>
<li><p>E. ParthÃ© and L. M. Gelato, âThe âbestâ unit cell for monoclinic
structures consistent with b axis unique and cell choice 1
of international tables for crystallography (1983)â, Acta
Cryst. A <strong>41</strong>, 142-151 (1985) [<a class="reference external" href="https://doi.org/10.1107/S0108767385000289">doi3</a>]</p></li>
<li><p>E. ParthÃ© and L. M. Gelato, âThe standardization of inorganic
crystal-structure dataâ, Acta Cryst. A
<strong>40</strong>, 169-183 (1984) [<a class="reference external" href="https://doi.org/10.1107/S0108767384000416">doi4</a>]</p></li>
<li><p>S. Hall, âSpace-group notation with an explicit originâ, Acta
Cryst. A <strong>37</strong>, 517-525 (1981) [<a class="reference external" href="https://doi.org/10.1107/S0567739481001228">doi1</a>]</p></li>
</ul>
</div>
<div class="section" id="space-group-operation-and-change-of-basis">
<h2><a class="toc-backref" href="#id3">Space group operation and change of basis</a><a class="headerlink" href="#space-group-operation-and-change-of-basis" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="basis-vectors-mathbf-a-mathbf-b-mathbf-c-or-mathbf-a-1-mathbf-a-2-mathbf-a-3">
<h3><a class="toc-backref" href="#id4">Basis vectors <span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}, \mathbf{c})\)</span> or <span class="math notranslate nohighlight">\((\mathbf{a}_1, \mathbf{a}_2, \mathbf{a}_3)\)</span></a><a class="headerlink" href="#basis-vectors-mathbf-a-mathbf-b-mathbf-c-or-mathbf-a-1-mathbf-a-2-mathbf-a-3" title="Permalink to this headline">Â¶</a></h3>
<p>In spglib, basis vectors are represented by three column vectors:</p>
<div class="math notranslate nohighlight" id="equation-basis-vectors">
<span class="eqno">(1)<a class="headerlink" href="#equation-basis-vectors" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\mathbf{a}= \begin{pmatrix}
a_x \\
a_y \\
a_z \\
\end{pmatrix},
\mathbf{b}= \begin{pmatrix}
b_x \\
b_y \\
b_z \\
\end{pmatrix},
\mathbf{c}= \begin{pmatrix}
c_x \\
c_y \\
c_z \\
\end{pmatrix},\end{split}\]</div>
<p>in Cartesian coordinates. Depending on the situation,
<span class="math notranslate nohighlight">\((\mathbf{a}_1, \mathbf{a}_2, \mathbf{a}_3)\)</span> is used instead of
<span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}, \mathbf{c})\)</span>.</p>
</div>
<div class="section" id="atomic-point-coordinates-boldsymbol-x">
<h3><a class="toc-backref" href="#id5">Atomic point coordinates <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span></a><a class="headerlink" href="#atomic-point-coordinates-boldsymbol-x" title="Permalink to this headline">Â¶</a></h3>
<p>Coordinates of an atomic point <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span> are represented
as three fractional values relative to basis vectors as follows,</p>
<div class="math notranslate nohighlight" id="equation-coordinate-triplet">
<span class="eqno">(2)<a class="headerlink" href="#equation-coordinate-triplet" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\boldsymbol{x}= \begin{pmatrix}
x_1 \\
x_2 \\
x_3 \\
\end{pmatrix},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(0 \le x_i &lt; 1\)</span>. A position vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> in
Cartesian coordinates is obtained by</p>
<div class="math notranslate nohighlight" id="equation-position-vector-1">
<span class="eqno">(3)<a class="headerlink" href="#equation-position-vector-1" title="Permalink to this equation">Â¶</a></span>\[\mathbf{x} = (\mathbf{a}, \mathbf{b}, \mathbf{c}) \boldsymbol{x}.\]</div>
<p>or</p>
<div class="math notranslate nohighlight" id="equation-position-vector-2">
<span class="eqno">(4)<a class="headerlink" href="#equation-position-vector-2" title="Permalink to this equation">Â¶</a></span>\[\mathbf{x} = \sum_i x_i \mathbf{a}_i.\]</div>
</div>
<div class="section" id="symmetry-operation-boldsymbol-w-boldsymbol-w">
<h3><a class="toc-backref" href="#id6">Symmetry operation <span class="math notranslate nohighlight">\((\boldsymbol{W}, \boldsymbol{w})\)</span></a><a class="headerlink" href="#symmetry-operation-boldsymbol-w-boldsymbol-w" title="Permalink to this headline">Â¶</a></h3>
<p>A symmetry operation consists of a pair of the rotation part
<span class="math notranslate nohighlight">\(\boldsymbol{W}\)</span> and translation part <span class="math notranslate nohighlight">\(\boldsymbol{w}\)</span>,
and is represented as <span class="math notranslate nohighlight">\((\boldsymbol{W}, \boldsymbol{w})\)</span> in the
spglib document. The symmetry operation transfers <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span> to
<span class="math notranslate nohighlight">\(\tilde{\boldsymbol{x}}\)</span> as follows:</p>
<div class="math notranslate nohighlight" id="equation-space-group-operation">
<span class="eqno">(5)<a class="headerlink" href="#equation-space-group-operation" title="Permalink to this equation">Â¶</a></span>\[\tilde{\boldsymbol{x}} = \boldsymbol{W}\boldsymbol{x} + \boldsymbol{w}.\]</div>
</div>
<div class="section" id="transformation-matrix-boldsymbol-p-and-origin-shift-boldsymbol-p">
<span id="def-transformation-and-origin-shift"></span><h3><a class="toc-backref" href="#id7">Transformation matrix <span class="math notranslate nohighlight">\(\boldsymbol{P}\)</span> and origin shift <span class="math notranslate nohighlight">\(\boldsymbol{p}\)</span></a><a class="headerlink" href="#transformation-matrix-boldsymbol-p-and-origin-shift-boldsymbol-p" title="Permalink to this headline">Â¶</a></h3>
<p>The transformation matrix <span class="math notranslate nohighlight">\(\boldsymbol{P}\)</span> changes choice of
basis vectors as follows</p>
<div class="math notranslate nohighlight" id="equation-transformation-matrix">
<span class="eqno">(6)<a class="headerlink" href="#equation-transformation-matrix" title="Permalink to this equation">Â¶</a></span>\[( \mathbf{a} \; \mathbf{b} \; \mathbf{c} )
= ( \mathbf{a}_\mathrm{s} \; \mathbf{b}_\mathrm{s} \;
\mathbf{c}_\mathrm{s} )  \boldsymbol{P},\]</div>
<p>where <span class="math notranslate nohighlight">\(( \mathbf{a} \; \mathbf{b} \; \mathbf{c} )\)</span> and <span class="math notranslate nohighlight">\((
\mathbf{a}_\mathrm{s} \; \mathbf{b}_\mathrm{s} \;
\mathbf{c}_\mathrm{s} )\)</span> are the basis vectors of an arbitrary system
and of a starndardized system, respectively. In general, the
transformation matrix is not limited for the transformation from the
standardized system, but can be used in between any systems possibly
transformed. It has to be emphasized that the transformation matrix
<strong>doesnât</strong> rotate a crystal in Cartesian coordinates, but just
changes the choices of basis vectors.</p>
<p>The origin shift <span class="math notranslate nohighlight">\(\boldsymbol{p}\)</span> gives the vector from the
origin of the standardized system <span class="math notranslate nohighlight">\(\boldsymbol{O}_\mathrm{s}\)</span> to
the origin of the arbitrary system <span class="math notranslate nohighlight">\(\boldsymbol{O}\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-origin-shift">
<span class="eqno">(7)<a class="headerlink" href="#equation-origin-shift" title="Permalink to this equation">Â¶</a></span>\[\boldsymbol{p} = \boldsymbol{O} - \boldsymbol{O}_\mathrm{s}.\]</div>
<p>Origin shift <strong>doesnât</strong> move a crystal in Cartesian coordinates, but
just changes the origin to measure the coordinates of atomic points.</p>
<p>A change of basis is described by the combination of the
transformation matrix and the origin shift denoted by
<span class="math notranslate nohighlight">\((\boldsymbol{P}, \boldsymbol{p})\)</span> where first the
transformation matrix is applied and then origin shift. The points in
the standardized system <span class="math notranslate nohighlight">\(\boldsymbol{x}_\mathrm{s}\)</span> and
arbitrary system <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span> are related by</p>
<div class="math notranslate nohighlight" id="equation-change-of-basis-1">
<span class="eqno">(8)<a class="headerlink" href="#equation-change-of-basis-1" title="Permalink to this equation">Â¶</a></span>\[\boldsymbol{x}_\mathrm{s} = \boldsymbol{P}\boldsymbol{x} +
\boldsymbol{p},\]</div>
<p>or equivalently,</p>
<div class="math notranslate nohighlight" id="equation-change-of-basis-2">
<span class="eqno">(9)<a class="headerlink" href="#equation-change-of-basis-2" title="Permalink to this equation">Â¶</a></span>\[\boldsymbol{x} = \boldsymbol{P}^{-1}\boldsymbol{x}_\mathrm{s} -
\boldsymbol{P}^{-1}\boldsymbol{p}.\]</div>
<p>A graphical example is shown below.</p>
<p><a class="reference internal" href="definitions/change-of-basis.png"><img alt="cob" src="definitions/change-of-basis.png" style="width: 20%;" /></a></p>
<p>(click the figure to enlarge)</p>
<p>In this example,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{P} = \begin{pmatrix}
\frac{1}{2} &amp; \frac{1}{2} &amp; 0 \\
\frac{\bar{1}}{2} &amp; \frac{1}{2} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}.\end{split}\]</div>
</div>
<div class="section" id="difference-between-rotation-and-transformation-matrices">
<h3><a class="toc-backref" href="#id8">Difference between rotation and transformation matrices</a><a class="headerlink" href="#difference-between-rotation-and-transformation-matrices" title="Permalink to this headline">Â¶</a></h3>
<p>A rotation matrix rotates (or mirrors, inverts) the crystal body with
respect to origin. A transformation matrix changes the choice of the
basis vectors, but does not rotate the crystal body.</p>
<p>A space group operation having no translation part sends an atom to
another point by</p>
<div class="math notranslate nohighlight">
\[\tilde{\boldsymbol{x}} = \boldsymbol{W}\boldsymbol{x},\]</div>
<p>where <span class="math notranslate nohighlight">\(\tilde{\boldsymbol{x}}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span> are
represented with respect to the same basis vectors <span class="math notranslate nohighlight">\((\mathbf{a},
\mathbf{b}, \mathbf{c})\)</span>. Equivalently the rotation is achieved by
rotating the basis vectors:</p>
<div class="math notranslate nohighlight" id="equation-rotation-matrix">
<span class="eqno">(10)<a class="headerlink" href="#equation-rotation-matrix" title="Permalink to this equation">Â¶</a></span>\[(\tilde{\mathbf{a}}, \tilde{\mathbf{b}}, \tilde{\mathbf{c}}) =
(\mathbf{a}, \mathbf{b}, \mathbf{c}) \boldsymbol{W}\]</div>
<p>with keeping the representation of the atomic point coordinates
<span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span> because</p>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{x}} = (\mathbf{a}, \mathbf{b}, \mathbf{c}) \tilde{\boldsymbol{x}}
= (\mathbf{a}, \mathbf{b}, \mathbf{c}) \boldsymbol{W}
\boldsymbol{x}
= (\tilde{\mathbf{a}}, \tilde{\mathbf{b}}, \tilde{\mathbf{c}})
\boldsymbol{x}.\]</div>
<p>The transformation matrix changes the choice of the basis vectors as:</p>
<div class="math notranslate nohighlight">
\[(\mathbf{a}', \mathbf{b}', \mathbf{c}') = (\mathbf{a}, \mathbf{b},
\mathbf{c}) \boldsymbol{P}.\]</div>
<p>The atomic position vector is not altered by this transformation, i.e.,</p>
<div class="math notranslate nohighlight">
\[(\mathbf{a}', \mathbf{b}', \mathbf{c}') \boldsymbol{x}' =
(\mathbf{a}, \mathbf{b}, \mathbf{c}) \boldsymbol{x}.\]</div>
<p>However the representation of the atomic point coordinates changes as follows:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{P} \boldsymbol{x}' = \boldsymbol{x}.\]</div>
<p>because</p>
<div class="math notranslate nohighlight">
\[(\mathbf{a}, \mathbf{b}, \mathbf{c}) \boldsymbol{P} \boldsymbol{x}'
= (\mathbf{a}', \mathbf{b}', \mathbf{c}') \boldsymbol{x}' =
(\mathbf{a}, \mathbf{b}, \mathbf{c}) \boldsymbol{x}.\]</div>
</div>
</div>
<div class="section" id="spglib-conventions-of-standardized-unit-cell">
<span id="def-standardized-unit-cell"></span><h2><a class="toc-backref" href="#id9">Spglib conventions of standardized unit cell</a><a class="headerlink" href="#spglib-conventions-of-standardized-unit-cell" title="Permalink to this headline">Â¶</a></h2>
<p>The standardization in spglib is achieved by <a class="reference internal" href="#def-transformation-and-origin-shift"><span class="std std-ref">a change of basis
transformation</span></a>. If
<a class="reference internal" href="#def-idealize-cell"><span class="std std-ref">idealization</span></a> as shown below is further
applied, the crystal can be rigidly rotated in Cartesian
coordinates.</p>
<div class="section" id="choice-of-basis-vectors">
<h3><a class="toc-backref" href="#id10">Choice of basis vectors</a><a class="headerlink" href="#choice-of-basis-vectors" title="Permalink to this headline">Â¶</a></h3>
<p>Using the APIs <code class="docutils literal notranslate"><span class="pre">spg_get_dataset</span></code>,
<code class="docutils literal notranslate"><span class="pre">spg_get_dataset_with_hall_number</span></code>, or <code class="docutils literal notranslate"><span class="pre">spg_standardize_cell</span></code>, the
starndardized unit cell is obtained. The âstarndardized unit cellâ in
this document means that the (conventional) unit cell structure is
standardized by the crystal symmetry and lengths of basis
vectors. This standardization in spglib is not unique, but upto space
group operations and generators of Euclidean normalizer. Crystals are
categorized by Hall symbols in 530 different types in terms of 230
space group types, unique axes, settings, and cell choices. Moreover
in spglib, lengths of basis vectors are used to choose the order of
<span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}, \mathbf{c})\)</span> if the order can not be
determined only by the symmetrical conventions.</p>
</div>
<div class="section" id="transformation-to-the-primitive-cell">
<span id="def-standardized-primitive-cell"></span><h3><a class="toc-backref" href="#id11">Transformation to the primitive cell</a><a class="headerlink" href="#transformation-to-the-primitive-cell" title="Permalink to this headline">Â¶</a></h3>
<p>In the standardized unit cells, there are five different centring
types available, base centrings of A and C, rhombohedral (R), body centred
(I), and face centred (F). The transformation is applied to the
standardized unit cell by</p>
<div class="math notranslate nohighlight" id="equation-transformation-to-primitive">
<span class="eqno">(11)<a class="headerlink" href="#equation-transformation-to-primitive" title="Permalink to this equation">Â¶</a></span>\[( \mathbf{a}_\mathrm{p} \; \mathbf{b}_\mathrm{p} \; \mathbf{c}_\mathrm{p} )
= ( \mathbf{a}_\mathrm{s} \; \mathbf{b}_\mathrm{s} \;
\mathbf{c}_\mathrm{s} )  \boldsymbol{P}_\mathrm{c},\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{a}_\mathrm{p}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{b}_\mathrm{p}\)</span>,
and <span class="math notranslate nohighlight">\(\mathbf{c}_\mathrm{p}\)</span> are the basis vectors of the
primitive cell and <span class="math notranslate nohighlight">\(\boldsymbol{P}_\mathrm{c}\)</span> is the
transformation matrix from the standardized unit cell to the primitive
cell. <span class="math notranslate nohighlight">\(\boldsymbol{P}_\mathrm{c}\)</span> for centring types are given
as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{P}_\mathrm{A} =
\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; \frac{1}{2} &amp; \frac{\bar{1}}{2} \\
0 &amp; \frac{1}{2} &amp; \frac{{1}}{2}
\end{pmatrix},
\boldsymbol{P}_\mathrm{C} =
\begin{pmatrix}
\frac{1}{2} &amp; \frac{{1}}{2} &amp; 0 \\
\frac{\bar{1}}{2} &amp; \frac{1}{2} &amp; 0\\
0 &amp; 0 &amp; 1
\end{pmatrix},
\boldsymbol{P}_\mathrm{R} =
\begin{pmatrix}
\frac{2}{3} &amp; \frac{\bar{1}}{3} &amp; \frac{\bar{1}}{3} \\
\frac{1}{3} &amp; \frac{{1}}{3} &amp; \frac{\bar{2}}{3} \\
\frac{1}{3} &amp; \frac{{1}}{3} &amp; \frac{{1}}{3}
\end{pmatrix},
\boldsymbol{P}_\mathrm{I} =
\begin{pmatrix}
\frac{\bar{1}}{2} &amp; \frac{{1}}{2} &amp; \frac{{1}}{2} \\
\frac{{1}}{2} &amp; \frac{\bar{1}}{2} &amp; \frac{{1}}{2} \\
\frac{{1}}{2} &amp; \frac{{1}}{2} &amp; \frac{\bar{1}}{2}
\end{pmatrix},
\boldsymbol{P}_\mathrm{F} =
\begin{pmatrix}
0 &amp; \frac{{1}}{2} &amp; \frac{{1}}{2} \\
\frac{{1}}{2} &amp; 0 &amp; \frac{{1}}{2} \\
\frac{{1}}{2} &amp; \frac{{1}}{2} &amp; 0
\end{pmatrix}.\end{split}\]</div>
<p>For rhombohedral lattice systems with the choice of hexagonal axes,
<span class="math notranslate nohighlight">\(\boldsymbol{P}_\mathrm{R}\)</span> is applied.</p>
</div>
<div class="section" id="def-idealize-cell">
<span id="idealization-of-unit-cell-structure"></span><h3><a class="toc-backref" href="#id12">Idealization of unit cell structure</a><a class="headerlink" href="#def-idealize-cell" title="Permalink to this headline">Â¶</a></h3>
<p>Spglib allows tolerance parameters to match a slightly distorted unit
cell structure to a space group type with some higher symmetry. Using
obtained symmetry operations, the distortion is removed to idealize
the unit cell structure. The coordinates of atomic points are
idealized using respective site-symmetries (Grosse-Kunstleve <em>et
al</em>. (2002)). The basis vectors are idealized by forceing them into
respective lattice shapes as follows. In this treatment, except for
triclinic crystals, crystals can be rotated in Cartesian coordinates,
which is the different type of transformation from that of the
change-of-basis transformation explained above.</p>
<div class="section" id="triclinic-lattice">
<h4>Triclinic lattice<a class="headerlink" href="#triclinic-lattice" title="Permalink to this headline">Â¶</a></h4>
<ul class="simple">
<li><p>Niggli reduced cell is used for choosing <span class="math notranslate nohighlight">\(\mathbf{a}, \mathbf{b}, \mathbf{c}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> is set along <span class="math notranslate nohighlight">\(+x\)</span> direction of Cartesian coordinates.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is set in <span class="math notranslate nohighlight">\(x\text{-}y\)</span> plane of Cartesian
coordinates so that <span class="math notranslate nohighlight">\(\mathbf{a}\times\mathbf{b}\)</span> is along
<span class="math notranslate nohighlight">\(+z\)</span> direction of Cartesian coordinates.</p></li>
</ul>
</div>
<div class="section" id="monoclinic-lattice">
<h4>Monoclinic lattice<a class="headerlink" href="#monoclinic-lattice" title="Permalink to this headline">Â¶</a></h4>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(b\)</span> axis is taken as the unique axis.</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha = 90^\circ\)</span> and <span class="math notranslate nohighlight">\(\gamma = 90^\circ\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(90^\circ &lt; \beta &lt; 120^\circ\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> is set along <span class="math notranslate nohighlight">\(+x\)</span> direction of Cartesian coordinates.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is set along <span class="math notranslate nohighlight">\(+y\)</span> direction of Cartesian coordinates.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is set in <span class="math notranslate nohighlight">\(x\text{-}z\)</span> plane of Cartesian coordinates.</p></li>
</ul>
</div>
<div class="section" id="orthorhombic-lattice">
<h4>Orthorhombic lattice<a class="headerlink" href="#orthorhombic-lattice" title="Permalink to this headline">Â¶</a></h4>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha = \beta = \gamma = 90^\circ\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> is set along <span class="math notranslate nohighlight">\(+x\)</span> direction of Cartesian coordinates.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is set along <span class="math notranslate nohighlight">\(+y\)</span> direction of Cartesian coordinates.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is set along <span class="math notranslate nohighlight">\(+z\)</span> direction of Cartesian coordinates.</p></li>
</ul>
</div>
<div class="section" id="tetragonal-lattice">
<h4>Tetragonal lattice<a class="headerlink" href="#tetragonal-lattice" title="Permalink to this headline">Â¶</a></h4>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha = \beta = \gamma = 90^\circ\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(a=b\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> is set along <span class="math notranslate nohighlight">\(+x\)</span> direction of Cartesian coordinates.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is set along <span class="math notranslate nohighlight">\(+y\)</span> direction of Cartesian coordinates.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is set along <span class="math notranslate nohighlight">\(+z\)</span> direction of Cartesian coordinates.</p></li>
</ul>
</div>
<div class="section" id="rhombohedral-lattice">
<h4>Rhombohedral lattice<a class="headerlink" href="#rhombohedral-lattice" title="Permalink to this headline">Â¶</a></h4>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha = \beta = \gamma\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(a=b=c\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{c}\)</span>
projected on <span class="math notranslate nohighlight">\(x\text{-}y\)</span> plane in Cartesian coordinates be
<span class="math notranslate nohighlight">\(\mathbf{a}_{xy}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{b}_{xy}\)</span>, and
<span class="math notranslate nohighlight">\(\mathbf{c}_{xy}\)</span>, respectively, and their angles be
<span class="math notranslate nohighlight">\(\alpha_{xy}\)</span>, <span class="math notranslate nohighlight">\(\beta_{xy}\)</span>,
<span class="math notranslate nohighlight">\(\gamma_{xy}\)</span>, respectively.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{c}\)</span>
projected along <span class="math notranslate nohighlight">\(z\)</span>-axis in Cartesian coordinates be
<span class="math notranslate nohighlight">\(\mathbf{a}_{z}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{b}_{z}\)</span>, and
<span class="math notranslate nohighlight">\(\mathbf{c}_{z}\)</span>, respectively.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}_{xy}\)</span> is set along <span class="math notranslate nohighlight">\(+x\)</span> direction of Cartesian
coordinates, and <span class="math notranslate nohighlight">\(\mathbf{b}_{xy}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{c}_{xy}\)</span>
are placed by angles <span class="math notranslate nohighlight">\(120^\circ\)</span> and <span class="math notranslate nohighlight">\(240^\circ\)</span> from
<span class="math notranslate nohighlight">\(\mathbf{a}_{xy}\)</span> counter-clockwise, respectively.</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha_{xy} = \beta_{xy} = \gamma_{xy} = 120^\circ\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(a_{xy} = b_{xy} = c_{xy}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(a_{z} = b_{z} = c_{z}\)</span>.</p></li>
</ul>
</div>
<div class="section" id="hexagonal-lattice">
<h4>Hexagonal lattice<a class="headerlink" href="#hexagonal-lattice" title="Permalink to this headline">Â¶</a></h4>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha = \beta = 90^\circ\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\gamma = 120^\circ\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(a=b\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> is set along <span class="math notranslate nohighlight">\(+x\)</span> direction of Cartesian coordinates.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is set in <span class="math notranslate nohighlight">\(x\text{-}y\)</span> plane of Cartesian coordinates.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is set along <span class="math notranslate nohighlight">\(+z\)</span> direction of Cartesian coordinates.</p></li>
</ul>
</div>
<div class="section" id="cubic-lattice">
<h4>Cubic lattice<a class="headerlink" href="#cubic-lattice" title="Permalink to this headline">Â¶</a></h4>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha = \beta = \gamma = 90^\circ\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(a=b=c\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> is set along <span class="math notranslate nohighlight">\(+x\)</span> direction of Cartesian coordinates.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is set along <span class="math notranslate nohighlight">\(+y\)</span> direction of Cartesian coordinates.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is set along <span class="math notranslate nohighlight">\(+z\)</span> direction of Cartesian coordinates.</p></li>
</ul>
</div>
</div>
<div class="section" id="rotation-introduced-by-idealization">
<h3><a class="toc-backref" href="#id13">Rotation introduced by idealization</a><a class="headerlink" href="#rotation-introduced-by-idealization" title="Permalink to this headline">Â¶</a></h3>
<p>In the idealization step presented above, the input unit cell crystal
strcuture can be rotated in the Cartesian coordinates.  The rotation
matrix <span class="math notranslate nohighlight">\(\boldsymbol{R}\)</span> of this rotation is defined by</p>
<div class="math notranslate nohighlight" id="equation-rigid-rotation-matrix">
<span class="eqno">(12)<a class="headerlink" href="#equation-rigid-rotation-matrix" title="Permalink to this equation">Â¶</a></span>\[( \bar{\mathbf{a}}_\mathrm{s} \;
\bar{\mathbf{b}}_\mathrm{s} \; \bar{\mathbf{c}}_\mathrm{s} )
= ( \boldsymbol{R} \mathbf{a}_\mathrm{s} \;
\boldsymbol{R} \mathbf{b}_\mathrm{s} \; \boldsymbol{R}
\mathbf{c}_\mathrm{s} ).\]</div>
<p>This rotation matrix rotates the standardized
crystal structure before idealization <span class="math notranslate nohighlight">\(( \mathbf{a}_\mathrm{s}
\; \mathbf{b}_\mathrm{s} \; \mathbf{c}_\mathrm{s} )\)</span> to that after
idealization <span class="math notranslate nohighlight">\(( \bar{\mathbf{a}}_\mathrm{s} \;
\bar{\mathbf{b}}_\mathrm{s} \; \bar{\mathbf{c}}_\mathrm{s} )\)</span> in
Cartesian coordinates of the given input unit cell.</p>
</div>
</div>
<div class="section" id="examples">
<h2><a class="toc-backref" href="#id14">Examples</a><a class="headerlink" href="#examples" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="crystallographic-choice-and-rigid-rotation">
<h3><a class="toc-backref" href="#id15">Crystallographic choice and rigid rotation</a><a class="headerlink" href="#crystallographic-choice-and-rigid-rotation" title="Permalink to this headline">Â¶</a></h3>
<p>The following example of a python script gives a crystal structure of
Br whose space group type is <em>Cmce</em>. The basis vectors
<span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}, \mathbf{c})\)</span> are fixed by the symmetry
crystal in the standardization. The C-centrng determines the c-axis,
and <em>m</em> and <em>c</em> operations in <em>Cmce</em> fix which directions a- and
b-axes should be with respect to each other axis. This is the first
one choice appearing in the list of Hall symbols among 6 different
choices for this space group type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">spglib</span>

<span class="c1"># Mind that the a, b, c axes are given in row vectors here,</span>
<span class="c1"># but the formulation above is given for the column vectors.</span>
<span class="n">lattice</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">7.17851431</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># a</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.99943947</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># b</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">8.57154746</span><span class="p">]]</span>  <span class="c1"># c</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">]]</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">35</span><span class="p">,]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="n">cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Space group type: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%d</span><span class="s2">)&quot;</span>
      <span class="o">%</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;international&#39;</span><span class="p">],</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Transformation matrix:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;transformation_matrix&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">%2d</span><span class="s2"> </span><span class="si">%2d</span><span class="s2"> </span><span class="si">%2d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Origin shift: </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;origin_shift&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p>This python script is saved in the file <code class="docutils literal notranslate"><span class="pre">example.py</span></code>. Then we get</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">python</span> <span class="n">example</span><span class="o">.</span><span class="n">py</span>
<span class="n">Space</span> <span class="n">group</span> <span class="nb">type</span><span class="p">:</span> <span class="n">Cmce</span> <span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="n">Transformation</span> <span class="n">matrix</span><span class="p">:</span>
   <span class="mi">1</span>  <span class="mi">0</span>  <span class="mi">0</span>
   <span class="mi">0</span>  <span class="mi">1</span>  <span class="mi">0</span>
   <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">1</span>
<span class="n">Origin</span> <span class="n">shift</span><span class="p">:</span> <span class="mf">0.000000</span> <span class="mf">0.500000</span> <span class="mf">0.500000</span>
</pre></div>
</div>
<p>No rotation was introduced in the idealization. Next, we swap a- and c-axes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">spglib</span>

<span class="c1"># Mind that the a, b, c axes are given in row vectors here,</span>
<span class="c1"># but the formulation above is given for the column vectors.</span>
<span class="n">lattice</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">8.57154746</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># a</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.99943947</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># b</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">7.17851431</span><span class="p">]]</span>  <span class="c1"># c</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.1203133</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.6203133</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.3796867</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.8796867</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.1203133</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.6203133</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.3796867</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.8796867</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]]</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">35</span><span class="p">,]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="n">cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Space group type: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%d</span><span class="s2">)&quot;</span>
      <span class="o">%</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;international&#39;</span><span class="p">],</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Transformation matrix:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;transformation_matrix&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">%2d</span><span class="s2"> </span><span class="si">%2d</span><span class="s2"> </span><span class="si">%2d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Origin shift: </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;origin_shift&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p>By this,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">python</span> <span class="n">spglib</span><span class="o">-</span><span class="n">example2</span><span class="o">.</span><span class="n">py</span>
<span class="n">Space</span> <span class="n">group</span> <span class="nb">type</span><span class="p">:</span> <span class="n">Cmce</span> <span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="n">Transformation</span> <span class="n">matrix</span><span class="p">:</span>
   <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">1</span>
   <span class="mi">0</span>  <span class="mi">1</span>  <span class="mi">0</span>
  <span class="o">-</span><span class="mi">1</span>  <span class="mi">0</span>  <span class="mi">0</span>
<span class="n">Origin</span> <span class="n">shift</span><span class="p">:</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span>
</pre></div>
</div>
<p>We get a non-identity transformation matrix, which wants to transform
back to the original (above) crystal structure by swapping a- and
c-axes. The transformation back of the basis vectors is achieved by
Eq. <a class="reference internal" href="#equation-transformation-matrix">(6)</a>. Next, we try to rotate rigidly the
crystal structure by <span class="math notranslate nohighlight">\(45^\circ\)</span> around c-axis in Cartesian
coordinates from the first one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">spglib</span>

<span class="c1"># Mind that the a, b, c axes are given in row vectors here,</span>
<span class="c1"># but the formulation above is given for the column vectors.</span>
<span class="n">lattice</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">5.0759761474456697</span><span class="p">,</span> <span class="mf">5.0759761474456697</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># a</span>
           <span class="p">[</span><span class="o">-</span><span class="mf">2.8280307701821314</span><span class="p">,</span> <span class="mf">2.8280307701821314</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># b</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">8.57154746</span><span class="p">]]</span>  <span class="c1"># c</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">]]</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">35</span><span class="p">,]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="n">cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Space group type: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%d</span><span class="s2">)&quot;</span>
      <span class="o">%</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;international&#39;</span><span class="p">],</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Transformation matrix:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;transformation_matrix&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">%2d</span><span class="s2"> </span><span class="si">%2d</span><span class="s2"> </span><span class="si">%2d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Origin shift: </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;origin_shift&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">python</span> <span class="n">spglib</span><span class="o">-</span><span class="n">example3</span><span class="o">.</span><span class="n">py</span>
<span class="n">Space</span> <span class="n">group</span> <span class="nb">type</span><span class="p">:</span> <span class="n">Cmce</span> <span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="n">Transformation</span> <span class="n">matrix</span><span class="p">:</span>
   <span class="mi">1</span>  <span class="mi">0</span>  <span class="mi">0</span>
   <span class="mi">0</span>  <span class="mi">1</span>  <span class="mi">0</span>
   <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">1</span>
<span class="n">Origin</span> <span class="n">shift</span><span class="p">:</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.500000</span>
</pre></div>
</div>
<p>The transformation matrix is kept unchanged even though the crystal
structure is rotated in Cartesian coordinates. The origin shift is
different but it changes only the order of atoms, so effectively it
does nothing.</p>
</div>
<div class="section" id="transformation-to-a-primitive-cell">
<h3><a class="toc-backref" href="#id16">Transformation to a primitive cell</a><a class="headerlink" href="#transformation-to-a-primitive-cell" title="Permalink to this headline">Â¶</a></h3>
<p>There are infinite number of choices of primitive cell. The
transformation from a primitive cell basis vectors to the other
primitive cell basis vectors is always done by an integer matrix
because any lattice points can be generated by the linear combination
of the three primitive basis vectors.</p>
<p>When we have a non-primitive cell basis vectors as given in the above
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lattice</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">7.17851431</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># a</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.99943947</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># b</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">8.57154746</span><span class="p">]]</span>  <span class="c1"># c</span>
</pre></div>
</div>
<p>This has the C-centring, so it must be transformed to a primitive
cell. A possible transformation is shown at
<a class="reference internal" href="#def-standardized-primitive-cell"><span class="std std-ref">Transformation to the primitive cell</span></a>, which is
<span class="math notranslate nohighlight">\(\boldsymbol{P}_\mathrm{C}\)</span>. With the following script:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">lattice</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">7.17851431</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># a</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.99943947</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># b</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">8.57154746</span><span class="p">]]</span>  <span class="c1"># c</span>
<span class="n">Pc</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
      <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">lattice</span><span class="p">),</span> <span class="n">Pc</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># given in row vectors</span>
</pre></div>
</div>
<p>we get the primitive cell basis vectors (shown in row vectors):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="mf">3.58925715</span> <span class="o">-</span><span class="mf">1.99971973</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span> <span class="mf">3.58925715</span>  <span class="mf">1.99971973</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">8.57154746</span><span class="p">]]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">find_primitive</span></code> gives a primitive cell that is obtained by
transforming standardized and idealized crystal structure to the
primitive cell using the transformation matrix. Therefore by this
script:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">spglib</span>

<span class="n">lattice</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">7.17851431</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.99943947</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">8.57154746</span><span class="p">]]</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">]]</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="n">cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span>

<span class="n">primitive_cell</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">find_primitive</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">primitive_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="mf">3.58925715</span> <span class="o">-</span><span class="mf">1.99971973</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span> <span class="mf">3.58925715</span>  <span class="mf">1.99971973</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">8.57154746</span><span class="p">]]</span>
</pre></div>
</div>
<p>This is same as what we manually obtained above.
Even when the basis vectors are rigidly rotated as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lattice</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">5.0759761474456697</span><span class="p">,</span> <span class="mf">5.0759761474456697</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
           <span class="p">[</span><span class="o">-</span><span class="mf">2.8280307701821314</span><span class="p">,</span> <span class="mf">2.8280307701821314</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">8.57154746</span><span class="p">]]</span>
</pre></div>
</div>
<p>the relationship of a, b, c axes is unchanged. Therefore the same
transformation matrix to the primitive cell can be used. Then we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mf">3.95200346</span> <span class="mf">1.12397269</span> <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span><span class="mf">1.12397269</span> <span class="mf">3.95200346</span> <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span><span class="mf">0.</span>         <span class="mf">0.</span>         <span class="mf">8.57154746</span><span class="p">]]</span>
</pre></div>
</div>
<p>However applying <code class="docutils literal notranslate"><span class="pre">find_primitive</span></code> rigidly rotates automatically and
so the following script doesnât give this basis vectors:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">spglib</span>

<span class="n">lattice</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">5.0759761474456697</span><span class="p">,</span> <span class="mf">5.0759761474456697</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
           <span class="p">[</span><span class="o">-</span><span class="mf">2.8280307701821314</span><span class="p">,</span> <span class="mf">2.8280307701821314</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">8.57154746</span><span class="p">]]</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">]]</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="n">cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span>

<span class="n">primitive_cell</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">find_primitive</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">primitive_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>but gives those with respect to the idealized ones:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="mf">3.58925715</span> <span class="o">-</span><span class="mf">1.99971973</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span> <span class="mf">3.58925715</span>  <span class="mf">1.99971973</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">8.57154746</span><span class="p">]]</span>
</pre></div>
</div>
<p>To obtain the rotated primitive cell basis vectors, we can use
<code class="docutils literal notranslate"><span class="pre">standardize_cell</span></code> as shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">spglib</span>

<span class="n">lattice</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">5.0759761474456697</span><span class="p">,</span> <span class="mf">5.0759761474456697</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
           <span class="p">[</span><span class="o">-</span><span class="mf">2.8280307701821314</span><span class="p">,</span> <span class="mf">2.8280307701821314</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">8.57154746</span><span class="p">]]</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">]]</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="n">cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span>
<span class="n">primitive_cell</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">standardize_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">to_primitive</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">no_idealize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">primitive_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>then we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mf">3.95200346</span> <span class="mf">1.12397269</span> <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span><span class="mf">1.12397269</span> <span class="mf">3.95200346</span> <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span><span class="mf">0.</span>         <span class="mf">0.</span>         <span class="mf">8.57154746</span><span class="p">]]</span>
</pre></div>
</div>
<p>which is equivalent to that we get manually. However using
<code class="docutils literal notranslate"><span class="pre">standardize_cell</span></code>, distortion is not removed for the distorted
crystal structure.</p>
</div>
<div class="section" id="computing-rigid-rotation-introduced-by-idealization">
<h3><a class="toc-backref" href="#id17">Computing rigid rotation introduced by idealization</a><a class="headerlink" href="#computing-rigid-rotation-introduced-by-idealization" title="Permalink to this headline">Â¶</a></h3>
<p>In spglib, rigid rotation is purposely introduced in the idealization
step though this is unlikely as a crystallographic operation.</p>
<p>The crystal structure in the following script is the same as shown
above, which is the one <span class="math notranslate nohighlight">\(45^\circ\)</span> rotated around c-axis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">spglib</span>

<span class="c1"># Mind that the a, b, c axes are given in row vectors here,</span>
<span class="c1"># but the formulation above is given for the column vectors.</span>
<span class="n">lattice</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">5.0759761474456697</span><span class="p">,</span> <span class="mf">5.0759761474456697</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># a</span>
           <span class="p">[</span><span class="o">-</span><span class="mf">2.8280307701821314</span><span class="p">,</span> <span class="mf">2.8280307701821314</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># b</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">8.57154746</span><span class="p">]]</span>  <span class="c1"># c</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.34688439</span><span class="p">,</span> <span class="mf">0.1203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.15311561</span><span class="p">,</span> <span class="mf">0.6203133</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.84688439</span><span class="p">,</span> <span class="mf">0.3796867</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.65311561</span><span class="p">,</span> <span class="mf">0.8796867</span><span class="p">]]</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">35</span><span class="p">,]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="n">cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Space group type: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%d</span><span class="s2">)&quot;</span>
      <span class="o">%</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;international&#39;</span><span class="p">],</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Transformation matrix:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;transformation_matrix&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">%2d</span><span class="s2"> </span><span class="si">%2d</span><span class="s2"> </span><span class="si">%2d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;std_lattice_after_idealization:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;std_lattice&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>we get</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Space</span> <span class="n">group</span> <span class="nb">type</span><span class="p">:</span> <span class="n">Cmce</span> <span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="n">Transformation</span> <span class="n">matrix</span><span class="p">:</span>
   <span class="mi">1</span>  <span class="mi">0</span>  <span class="mi">0</span>
   <span class="mi">0</span>  <span class="mi">1</span>  <span class="mi">0</span>
   <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">1</span>
<span class="n">std_lattice_after_idealization</span><span class="p">:</span>
<span class="p">[[</span><span class="mf">7.17851431</span> <span class="mf">0.</span>         <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span><span class="mf">0.</span>         <span class="mf">3.99943947</span> <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span><span class="mf">0.</span>         <span class="mf">0.</span>         <span class="mf">8.57154746</span><span class="p">]]</span>
</pre></div>
</div>
<p>From Eq. <a class="reference internal" href="#equation-transformation-matrix">(6)</a>, the standardized basis vectors
<strong>before</strong> idealization <span class="math notranslate nohighlight">\(( \mathbf{a}_\mathrm{s} \; \mathbf{b}_\mathrm{s}
\; \mathbf{c}_\mathrm{s} )\)</span> is obtained by (after <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">numpy</span> <span class="pre">as</span> <span class="pre">np</span></code>)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">std_lattice_before_idealization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">lattice</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;transformation_matrix&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
<span class="nb">print</span><span class="p">(</span><span class="n">std_lattice_before_idealization</span><span class="p">)</span>
</pre></div>
</div>
<p>which is (in row vectors)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="mf">5.07597615</span>  <span class="mf">5.07597615</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">2.82803077</span>  <span class="mf">2.82803077</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">8.57154746</span><span class="p">]]</span>
</pre></div>
</div>
<p>This is different from the standardized basis vectors <strong>after</strong>
idealization <span class="math notranslate nohighlight">\(( \bar{\mathbf{a}}_\mathrm{s} \;
\bar{\mathbf{b}}_\mathrm{s} \; \bar{\mathbf{c}}_\mathrm{s} )\)</span>.  Unless
this crystal strucutre is distorted from the crystal structure that
has the ideal symmetry, this means that the crystal was rotated
rigidly in the idealization step by</p>
<div class="math notranslate nohighlight">
\[( \bar{\mathbf{a}}_\mathrm{s} \;
\bar{\mathbf{b}}_\mathrm{s} \; \bar{\mathbf{c}}_\mathrm{s} )
= ( \boldsymbol{R} \mathbf{a}_\mathrm{s} \;
\boldsymbol{R} \mathbf{b}_\mathrm{s} \; \boldsymbol{R}
\mathbf{c}_\mathrm{s} ).\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{R}\)</span> is the rotation
matrix. This is computed by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;std_lattice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
           <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">std_lattice_before_idealization</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
</pre></div>
</div>
<p>and we get</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="mf">0.70710678</span>  <span class="mf">0.70710678</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">0.70710678</span>  <span class="mf">0.70710678</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">1.</span>        <span class="p">]]</span>
</pre></div>
</div>
<p>This equals to</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
\cos\theta &amp; -\sin\theta &amp; 0 \\
\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix},\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(\theta = -\pi/4\)</span> and <span class="math notranslate nohighlight">\(\det(\boldsymbol{R})=1\)</span> when
no distortion. <code class="docutils literal notranslate"><span class="pre">dataset['std_rotation_matrix'])</span></code> gives
approximately the same result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="mf">0.70710678</span>  <span class="mf">0.70710678</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">0.70710678</span>  <span class="mf">0.70710678</span>  <span class="mf">0.</span>        <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">1.</span>        <span class="p">]]</span>
</pre></div>
</div>
<p>In summary,</p>
<div class="math notranslate nohighlight">
\[( \bar{\mathbf{a}}_\mathrm{s} \;
\bar{\mathbf{b}}_\mathrm{s} \; \bar{\mathbf{c}}_\mathrm{s} )  \boldsymbol{P}
= ( \boldsymbol{R} \mathbf{a} \; \boldsymbol{R} \mathbf{b} \;
\boldsymbol{R} \mathbf{c} ).\]</div>
<p>The atomic point coordinates in <span class="math notranslate nohighlight">\(( \bar{\mathbf{a}}_\mathrm{s}
\; \bar{\mathbf{b}}_\mathrm{s} \; \bar{\mathbf{c}}_\mathrm{s} )\)</span>
are simply obtained by Eq. <a class="reference internal" href="#equation-change-of-basis-1">(8)</a> since the
rotation doesnât affect them.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../modules.html" class="btn btn-neutral float-right" title="dichlib" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="space_group_operation.html" class="btn btn-neutral float-left" title="Space Group Operation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Keiyu Mizokami

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>